{
  "compilerOptions": {
    /* https://aka.ms/tsconfig.json 를 방문하면 해당 파일에 대한 더 많은 정보를 얻을 수 있습니다. */
    // 옵션은 아래와 같은 형식으로 구성되어 있습니다.
    // "모듈 키": 모듈 값                        /* 설명: 사용가능 옵션 (설명이 "~ 여부"인 경우 'true', 'false') */
    /* 기본 옵션 */
    "incremental": true /* 증분 컴파일 설정 여부 */,
    "target": "es2017" /* 사용할 특정 ECMAScript 버전 설정: 'ES3' (기본), 'ES5', 'ES2015', 'ES2016', 'ES2017', 'ES2018', 'ES2019', 'ES2020', 혹은 'ESNEXT'. */,
    "module": "esnext" /* 모듈을 위한 코드 생성 설정: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', 'es2020', or 'ESNext'. */,
    "lib": [
      "dom" /* DOM APIs 에 대한 타입스크립트 지원 */,
      "dom.iterable" /* DOM APIs 중 Iteration 에 대한 추가적인 타입스크립트 지원 */,
      "esnext" /* ES2015 (ES6) 이후의 문법 지원을 위해 */
    ] /* 컴파일에 포함될 라이브러리 파일 목록 */,
    "allowJs": true /* 자바스크립트 파일 컴파일 허용 여부 */,
    // "checkJs": true,                       /* .js 파일의 오류 검사 여부 */
    "jsx": "preserve" /* JSX 코드 생성 설정: 'preserve', 'react-native', 혹은 'react' 등 계속 옵션이 추가되는중, 공식 문서 참조 */,
    // * 왜? "react" 보다 "react-jsx" 옵션을 선호하는가? https://stackoverflow.com/a/73518971
    // "declaration": true,                   /* '.d.ts' 파일 생성 여부. */
    // "declarationMap": true,                /* 각 '.d.ts' 파일의 소스맵 생성 여부. */
    // "sourceMap": true,                     /* '.map' 파일 생성 여부. */
    // "outFile": "./",                       /* 단일 파일로 합쳐서 출력합니다. */
    // "outDir": "./",                        /* 해당 디렉토리로 결과 구조를 보냅니다. */
    // "rootDir": "./",                       /* 입력 파일의 루트 디렉토리(rootDir) 설정으로 --outDir로 결과 디렉토리 구조를 조작할 때 사용됩니다. */
    // "composite": true,                     /* 프로젝트 컴파일 여부 */
    // "tsBuildInfoFile": "./",               /* 증분 컴파일 정보를 저장할 파일 */
    // "removeComments": true,                /* 주석 삭제 여부 */
    "noEmit": true /* 결과 파일 내보낼지 여부, Babel 이나 SWC 를 통한 Typescipt 컴파일 사용을 위해 */,
    // * True 인 경우 본 Typescript 는 에디터 통합 기능을 제공하기 위한 도구 혹은 소스 코드 타입 체커로만 사용
    // "importHelpers": true,                 /* 'tslib'에서 헬퍼를 가져올 지 여부 */
    // "downlevelIteration": true,            /* 타겟이 'ES5', 'ES3'일 때에도 'for-of', spread 그리고 destructuring 문법 모두 지원 */
    "isolatedModules": true /* 각 파일을 분리된 모듈로 트랜스파일 ('ts.transpileModule'과 비슷합니다). 꼭 import / export 로 닫아야하게끔 강제 */,
    // * Babel 아닌 다른 Transpiler 사용시, 단일 파일단위로 Transpile 하기 때문에 본 옵션을 키는것이 좋음
    /* 엄격한 타입-확인 옵션 */
    "strict": true /* 모든 엄격한 타입-체킹 옵션 활성화 여부 */,
    // "noImplicitAny": true,                 /* 'any' 타입으로 구현된 표현식 혹은 정의 에러처리 여부 */
    // "strictNullChecks": true,              /* 엄격한 null 확인 여부 */
    // "strictFunctionTypes": true,           /* 함수 타입에 대한 엄격한 확인 여부 */
    // "strictBindCallApply": true,           /* 함수에 엄격한 'bind', 'call' 그리고 'apply' 메소드 사용 여부 */
    // "strictPropertyInitialization": true,  /* 클래스의 값 초기화에 엄격한 확인 여부 */
    // "noImplicitThis": true,                /* 'any' 타입으로 구현된 'this' 표현식 에러처리 여부 */
    // "alwaysStrict": true,                  /* strict mode로 분석하고 모든 소스 파일에 "use strict"를 추가할 지 여부 */
    /* 추가적인 확인 */
    // "noUnusedLocals": true,                /* 사용되지 않은 지역 변수에 대한 에러보고 여부 */
    // "noUnusedParameters": true,            /* 사용되지 않은 파라미터에 대한 에러보고 여부 */
    // "noImplicitReturns": true,             /* 함수에서 코드의 모든 경로가 값을 반환하지 않을 시 에러보고 여부 */
    "noFallthroughCasesInSwitch": true /* switch문에서 fallthrough 케이스에 대한 에러보고 여부 */,
    /* 모듈 해석 옵션 */
    "moduleResolution": "bundler" /* 모듈 해석 방법 설정: 'node' (Node.js) 혹은 'classic' (TypeScript pre-1.6). */,
    // "baseUrl": "./",                       /* non-absolute한 모듈 이름을 처리할 기준 디렉토리 */
    "paths": {
      "@/*": [
        "./src/*"
      ]
    } /* 'baseUrl'를 기준으로 불러올 모듈의 위치를 재지정하는 엔트리 시리즈 */,
    /* 상대경로가 아닌 절대경로를 사용할 것, import 시 '../././././././././Hello' 같은것을 방지하기 위해. VSCode 와 연동할 것 */
    // "rootDirs": [],                        /* 결합된 컨텐츠가 런타임에서의 프로젝트 구조를 나타내는 루트 폴더들의 목록 */
    // "typeRoots": [],                       /* 타입 정의를 포함할 폴더 목록, 설정 안 할 시 기본적으로 ./node_modules/@types로 설정 */
    // "types": [],                           /* 컴파일중 포함될 타입 정의 파일 목록 */
    // "allowSyntheticDefaultImports": true,  /* default export이 아닌 모듈에서도 default import가 가능하게 할 지 여부, 해당 설정은 코드 추출에 영향은 주지 않고, 타입확인에만 영향을 줍니다. */
    "esModuleInterop": true /* 모든 imports에 대한 namespace 생성을 통해 CommonJS와 ES Modules 간의 상호 운용성이 생기게할 지 여부,  'allowSyntheticDefaultImports'를 암시적으로 승인합니다. */,
    // "preserveSymlinks": true,              /* symlik의 실제 경로를 처리하지 않을 지 여부 */
    // "allowUmdGlobalAccess": true,          /* UMD 전역을 모듈에서 접근할 수 있는 지 여부 */
    /* 소스 맵 옵션 */
    // "sourceRoot": "",                      /* 소스 위치 대신 디버거가 알아야 할 TypeScript 파일이 위치할 곳 */
    // "mapRoot": "",                         /* 생성된 위치 대신 디버거가 알아야 할 맵 파일이 위치할 곳 */
    // "inlineSourceMap": true,               /* 분리된 파일을 가지고 있는 대신, 단일 파일을 소스 맵과 가지고 있을 지 여부 */
    // "inlineSources": true,                 /* 소스맵과 나란히 소스를 단일 파일로 내보낼 지 여부, '--inlineSourceMap' 혹은 '--sourceMap'가 설정되어 있어야 한다. */
    /* 실험적 옵션 */
    // "experimentalDecorators": true,        /* ES7의 decorators에 대한 실험적 지원 여부 */
    // "emitDecoratorMetadata": true,         /* decorator를 위한 타입 메타데이터를 내보내는 것에 대한 실험적 지원 여부 */
    /* 추가적 옵션 */
    "skipLibCheck": true /* 정의 파일의 타입 확인을 건너 뛸 지 여부 */,
    "forceConsistentCasingInFileNames": true /* 같은 파일에 대한 일관되지 않은 참조를 허용하지 않을 지 여부 */,
    "resolveJsonModule": true /* 확장자가 .json인 모듈의 import를 허용, 정적 JSON 형태에 근거하여 해당 import에 대한 타입까지 자동으로 만들어 낸다. */,
    "plugins": [
      {
        "name": "next"
      }
    ]
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    "src/app/firebase/page.jsx"
  ],
  /* "files" 와 "include" 모두 지정되어 있지 않다면 컴파일러는 기본적으로 "exclude" 속성을 사용하여 제외된 것은 제외하고 모든 TypeScript (.ts,.d.ts 그리고 .tsx) 파일을 포함하는 디렉토리와 하위 디렉토리에 포함 */
  "exclude": [
    "node_modules"
  ]
  /* "exclude" 속성에 디렉토리가 지정되지 있지 않다면 기본적으로 node_modules, bower_components, jspm_packages 그리고 <outDir>를 제외 */
}
